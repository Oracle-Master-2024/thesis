
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
This section covers the integration process of how the new allocators are used in the ZGC in order to perform allocations in the external fragmentation of pages. This sections will also cover the intricacies of ZGC that has guided the decision-making process during the implementation

\subsection{Intricacies of ZGC}
As mentioned in Section~\ref*{sec:background}, ZGC is a \textbf{regional}, \textbf{concurrent}, \textbf{generational}, garbage collector. There are various design choices in the ZGC that have made this possible, and these design choices will have to be addressed in order to maintain these properties with a new allocator in place. 
\begin{description}
    \item[Regional] Since memory is managed regionally using pages in ZGC, the entire available memory can be seen as split up into many small segments of memory. ZGC is heavily based around the regionality of the memory. Relocations and aging is handled on a page-by-page basis, which is a central part of ZGC's design.
    \item[Generational] ZGC is a generational garbage collector, which means that some allocations are deemed young, and some old. This is done on a regional basis, where every object inside one page are considered to be the same age. The age is determined based on how many GC cycles the page has survived without being relocated due to fragmented memory. Objects in pages which are relocated are moved into pages with one age above the current one, and the pages that are not selected to be relocated will themselves increase their age. With the integration of a new allocator able to recycle already existing pages, the age of the pages will have to be acknowledged in order to choose which page to relocate to.
    \item[Concurrent] With the property of being a concurrent garbage collector, ZGC is able to run garbage collection on multiple threads at the same time. When implementing a new allocator, it is important that said allocator will not halt the program by having multiple threads poking at it at the same time. The program must also consider the concurrency of having the garbage collector run concurrently with the mutator threads running the Java program.
\end{description}

\subsection{Integration Problems}
The three different topics of ZGC being regional, generational, and concurrent are going to be central to all changes to ZGC that are needed for integrating the new allocator. Any changes to the implementation will have an impact on these three aspects, and therefore it is important to have a holistic view of the changes that are made.
\subsubsection{Selecting Pages to Recycle}
In order to select which pages are deemed viable as recyclable, the behavior of how ZGC treats pages right before the relocation phase of the garbage collection cycle needs to change. In ZGC, the relocation of pages is based on the amount of memory that has to be relocated from each page. Pages with small amounts of allocated memory will be prioritized for relocation. In Figure \ref{fig:rel_set_selector}, ZGC's way of constructing a relocation set is illustrated. Pages with small amounts of allocated data are marked as selected, which means the objects inside it will be relocated in the future. Pages with large amounts of allocated data are put in another set of pages where they are marked as survivors, and the objects inside them will stay in the same page until the next garbage collection cycle. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{example-image-a}
    \caption{TODO (an image of a set of pages, colored based on their fragmentation, the image shows how some of the pages are marked as selected. The other pages are marked as survivors.)}
    \label{fig:rel_set_selector}
\end{figure} 

With the new integration of a free list based allocator, the mission is to target the set of pages marked as survivors, and make it possible to move objects from the selected pages to the survivors. This change impacts the assumption that ZGC makes about the surviving pages. They have previously been ignored until the next garbage collection cycle, and no new allocations are done. The new implementation will have to change this assumption, leading to states for the pages that need to be handled differently by ZGC.

Something to consider is also how the relocation selection has previously selected how many pages to relocate objects from. It does this by looking at XXXXXXXXXX, but with a new way of recycling unused memory, this can perhaps be changed.

\subsubsection{Initializing the Free List}
Once available pages have been selected, the allocator has to be initialized in the page. This requires ZGC to tell the allocator where objects are allocated, and by doing that, the allocator can construct a free list of where the unused space is located. This can only be done after the marking phase of the garbage collection cycle, since the marking phase denotes where the live objects are located. 

\subsubsection{Allocating Using the New Allocator}
Allocations have previously only been done using the bump pointer allocator, but with the new allocator, the allocator will be used for both bump pointer allocations, as well as free list allocations. The two different methods offer different advantages. Bump pointers are fast, but they are not able to handle fragmentation. Free list allocations are able to handle fragmentation, but they are slower than bump pointers. The new allocator will have to be able to handle both of these cases, and therefore the allocator must be able to switch between the two methods depending on the situation. 

At some points, the allocator might not be able to construct a free list since there is no live data available in the page. In this case, the allocator will have to fall back to using the bump pointer allocator. This might happen in the case of a page being promoted from being a young to an old page. The new solution must handle this case.

\subsection{Implemented Changes}
\subsubsection{Selecting Recyclable Pages}
In order to recycle pages, the relocation process was changed to include storage for pages that are deemed viable for recycling. The main change was that ZGC now not only considers the pages with objects that are going to be relocated, but also the pages that are not selected. During the same time as these pages would usually just continue existing in memory, the recycling process begins. The pages that are selected for recycling are then marked as such based on the amount of free space that is available in the page. If there is enough free space, the page is marked as a target page for recycling and will be registered in the current generation of the GC. If the free space is not enough, it will be deemed unworthy of being recycled and will be marked as a survivor page. This threshold that determines whether or not a page is worth recycling is currently set by a flag in the JVM, but can be changed by the user. In Section~\ref{sec:results}, the threshold is explained in more detail, and the results show what the benetfits are of changing the threshold.

The page selection process is done concurrently on possibly multiple threads at the same time. Therefore, a method of avoiding race conditions was implemented. The race conditions can happen when two threads have both gathered a set of recyclable pages, and then both threads try to register the pages for ZGC to use for relocation. This was solved by achieving mutual exclusion on the set of pages that are being considered for relocation by implementing a lock. When one thread is registering their pages, another thread will have to wait until the first thread has finished registering their pages.

\subsubsection{Initializing the Free List}
The integration of the allocator involves constructing an allocator for every Z-page that needs one. This means that the free lists that are going to be accessed by each allocator is going to be constructed from a continuous section of memory.

The initialization of the free list has to be done before the GC tries to use it to allocate something, but most importantly after the marking phase of the garbage collector. In order to construct the free list, all the currently live objects in the page must be taken into account. To map out the areas of free memory the page traverses through all of its live objects and if there is any space between the object which is not allocated it will be freed. In Algorithm~\ref{alg:init}, the process of creating the free list from the live map is shown.

\begin{algorithm}{}
    \caption{\textproc{init\_free\_list}$(A,L)$}
    \label{alg:init}
    \begin{algorithmic}[1]
        \Require 
        \Statex $A$: An allocator.
        \Statex $L$: A livemap of live objects ordered by position in memory. 
        \Ensure 
        \Statex $A$ has a complete free list.
        \State $curr\gets start$ \Comment{Start at the beginning of memory}
        \ForAll{$l \in L$}
        \If{$l_{start} - curr > 0$}
        \State $A$.free\_range$(curr, l_{start})$ \Comment{Mark the free region of memory}
        \EndIf
        \State $curr\gets l_{start} + l_{size}$ \Comment{Jump forwards to next potential gap in memory}
        \EndFor
        \State $A$.free\_range$(curr,end)$ \Comment{Mark the last region to the end of the page as free}
    \end{algorithmic}
\end{algorithm}

\subsubsection{Using the Allocator}
The free list allocated has a more computationally heavy allocation compared to the bump pointer which is a lot faster. This means that we want to use the bump pointer only when necessary. After relocation is done, we also want to disengage the allocator and continue using bump pointer allocations. The integration of this functionality is based on a previous method used in ZGC, the sequence number.

In order to keep track of the allocator, a new type of sequence number is stored in the Z-page's memory, which is in the code referred to as an \textit{allocator sequence number}. The problem we're trying to solve is that an allocator is not supposed to be used if the data inside it is not up-to-date with the latest available liveness data. The allocator might have been used in previous garbage collections, which makes it possible that the allocator is not ready to be used during this garbage collection cycle yet. This is why we need to keep track of a sequence number which tells us the last time the allocator was updated.

The sequence number for the allocator can be updated only if it meets two criteria: the allocator has been selected as a recycled page, and the initialization process of the free list was successful. If both criteria are met, the Z-page can update its allocator sequence number to match with the current sequence number of the GC iteration, and will be ready to start allocating objects.
