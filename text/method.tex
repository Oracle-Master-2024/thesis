
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

\subsection{Integration Method}
This project outlines the integration of a new feature in a large code base. New implementations in large code bases tend to have bigger impacts than intended, since it is hard to know which parts of the system is going to be impacted. The integration method used during this thesis exists of two different phases, the identification phase, and then the implementation phase. 

The goal of the first identification phase is to study the behaviour of the program in the areas which are going to be impacted. This involves reading the code, changing the code to see the impacts, and also talking to the authors of the code in order to better understand what implications a small change might have. The goal is that by the end of this phase, enough information would be gathered about the different parts of the system such that it would be easier to identify which parts of the code have to be changed in order to implement the new feature.

The second phase involves the process of actually implementing the desired changes. Firstly, a design of the implementation is made from the gathered knowledge of the identification phase. Following this, an iterative method of implementing the design and testing it is done. If the implementation works like intended, the implementation is considered done, and if the implementation does not work like intended, the implementation phase is restarted and a new design has to be made from the knowledge gathered from the failed tests.

\subsection{Exploratory Programming}
The main method for implementing new changes to the JVM code was using exploratory programming. This method implies doing changes to the code and seeing what impacts the changes have based on data that is collected from the program. Some tools used to facilitate this process were debuggers, and logging tools. In this section I explain two useful tools that simplifies the process of understanding the code.
\subsubsection{Debuggers}
A debugger is a tool that is able to run your program with an interface to let the developer know the values of certain variables, or locations of memory addresses. A useful tool used during this project is the \textit{rr\_debugger}, designed by O'Callahan et al.~\cite{rrdebugger}, which can be used to record and replay a program's execution with deterministic behavior. This makes it possible to view parts of the program at different times. This is very useful in the context of the Open JDK, since the code consists of several tens of thousands lines of code, which makes it easy to have different parts of the system interacting with each other without the developer knowing. Finding which areas in the code is causing the problem is very important for successfully debugging a faulty program, and this is what the debugger is used for.

\subsubsection{Logging}
The Open JDK has access to logging tools which can produce output files with information about the JVM during its runtime~\cite{https://inside.java/2022/11/07/sip071/}. This is a powerful tool when working with a large code base, because it allows for user-friendly interpretation of the execution of code inside the JVM. While debuggers are useful for understanding the code's execution, the logs provide a more summarized explanation of how the code was executed. 

The JVM is already equipped with different types of log outputs, such as logs that display the performance of the garbage collector. By implementing a new allocation strategy, the JVM can be further equipped with useful information about the performance of the free-list allocator. This is used during this thesis to gather valuable insights into the performance of the new allocators.