% Gc handbook source where?
As previously mentioned, garbage collection is a form of automatic memory management where the system identifies and cleans up unused objects, which are considered garbage. This removes the requirement of managing memory from the user, which reduces the possibility of memory-related issues occurring. This also removes some control from the user, and could lead to suboptimal usage of system memory.

From the perspective of the GC, The user program can be viewed as only a memory mutator. The GC's only concern is the management of memory access, rather than the program's functionality. As such, the threads of the user program are commonly referred to as mutator threads. 

During GC execution, it may be necessary to temporarily halt the mutator threads, which is known as a stop-the-world approach. From the user program's perspective, the GC appears to be atomic, although extended pauses may not be desirable. Additionally, the GC can also operate concurrently and in parallel with the mutator threads, leading to increased complexity and challenges in identifying live objects. Most GCs fall somewhere in between these two extremes, running mainly concurrently but occasionally requiring pauses in the user program.

There exist numerous garbage collection strategies. One is the very simple mark-sweep algorithm. This algorithm begins by identifying the directly accessible ``root'' objects. These objects are then marked as live and scanned to identify any new linking objects. This process continues recursively until all live objects have been identified. Afterward, the heap is swept, freeing all objects that were not previously marked.

The mark-sweep algorithm does not relocate objects, which can result in higher levels of external fragmentation. The mark-compact algorithm addresses this issue. Like mark-sweep, it traverses the heap and marks all live objects. However, instead of sweeping, live objects are relocated to either the top or bottom of the heap. This approach reduces fragmentation and can be managed using a simpler bump-pointer allocator. However, it may be necessary to repeat this process multiple times depending on the positioning of live objects, as they could potentially collide with the moving operation.

This problem is solved by copying garbage collectors. The copy algorithm divides heaps into many logical units. Allocations are made in the same way as mark-compact, allocating onto these units and marking them as not empty. When garbage collection is carried out, the object is moved to another empty unit, rather than to the edge of the heap. Once all living objects have been moved from the unit, it is again marked empty. Using the copying algorithms With few units, heap size is significantly reduced. Using it with many units, garbage collection may instead need to be done more often.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End: